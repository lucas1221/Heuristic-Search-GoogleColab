# -*- coding: utf-8 -*-
"""TRABALHO1-BuscaHeuristica_t01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YBN92lTxbv0HEcOMR8pb_2RnTvwlt8i0
"""

import copy

def valid(x,y):
    r = True
    if x < 0 : r = False
    if x > 2 : r = False
    if y < 0 : r = False
    if y > 2 : r = False
    return r



# s = [[4,1,3],[2,5,6],[0,7,8]]

# 4 1 3
# 2 5 6
# 0 7 8

def sons(s):
    r = []
    x = None
    y = None
    #localiza zero
    for i in range(len(s)):
        for j in range(len(s[i])):
            if s[i][j] == 0:
                x = i
                y = j
    # cima
    vx = x - 1
    vy = y
    if (valid(vx,vy)):
        ts = copy.deepcopy(s)
        t = ts[vx][vy]
        ts[vx][vy] = ts[x][y]
        ts[x][y] = t
        r.append(ts)
    # baixo
    vx = x + 1
    vy = y
    if (valid(vx,vy)):
        ts = copy.deepcopy(s)
        t = ts[vx][vy]
        ts[vx][vy] = ts[x][y]
        ts[x][y] = t
        r.append(ts)

    # direita
    vx = x 
    vy = y +1
    if (valid(vx,vy)):
        ts = copy.deepcopy(s)
        t = ts[vx][vy]
        ts[vx][vy] = ts[x][y]
        ts[x][y] = t
        r.append(ts)

    # esquerda
    vx = x 
    vy = y - 1
    if (valid(vx,vy)):
        ts = copy.deepcopy(s)
        t = ts[vx][vy]
        ts[vx][vy] = ts[x][y]
        ts[x][y] = t
        r.append(ts)

    return r

def printPuzzle(s):
    for v in s:
        print(v)

def son2str(s):
    s1 = s[0]+s[1]+s[2]
    return ''.join([str(v) for v in s1])

def bfs(start,goal):
    l = [start]
    fathers = dict()
    visited = [start]
    while (len(l)>0):
        father = l[0]
        del l[0]
        for son in sons(father):
            if son not in visited:
                visited.append(son)
                print(len(visited))
                fathers[son2str(son)] = father
                if son == goal:
                    res = []
                    node = son
                    while node != start:
                        res.append(node)
                        node = fathers[son2str(node)]
                    res.append(start)
                    res.reverse()
                    print(res)
                    return res
                else:
                    l.append(son)
    print("Sem Solucao")

s = [[4,3,2],[0,1,6],[7,5,8]]

# 4 1 3       1 2 3
# 2 5 6   ->  4 5 6
# 0 7 8       7 8 0
resp = bfs(s,[[1,2,3],[4,5,6],[7,8,0]])
for s in resp:
    printPuzzle(s)
    print()

"""**Distância de Manhatan**"""

def h2(a,b): # distancia de manhatan
    dist = 0
    tam = len(a)*len(a[0])
    v = [[] for i in range(tam)]
    for i in range(len(a)):
        for j in range(len(a[i])):
            v[a[i][j]].append((i,j))
            v[b[i][j]].append((i,j))
    for i in range(tam):
        dist += abs(v[i][0][0]-v[i][1][0]) + abs(v[i][0][1]-v[i][1][1])
    return dist

start = [[4,1,3],[2,5,6],[0,7,8]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]
# 4 1 3       1 2 3
# 2 5 6   ->  4 5 6
# 0 7 8       7 8 0
# 1 +2 +0+1+0 +0+1+1+2 = 8
h2(start,goal)

"""**1 - (peso 1) - Você deverá implementar uma heurística 1 que conta o número de posições erradas.**"""

def h1(a,b): # heuristica 1 conta o número de posições erradas.
    erradas = 0
    for x in range(3):
        for y in range(3):
            if (a[x][y] != ' '):
                if (a[x][y] != b[x][y]):
                      erradas += 1       
    return erradas

start = [[4,1,3],[2,5,6],[0,7,8]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

h1(start,goal)

from heapq import heappush, heappop

def busca_heuristica(start,goal,heuristica):
    h = []
    heappush(h,(heuristica(start,goal),start))
    fathers = dict()
    visited = [start]
    while (len(h)>0):
        (_,father) = heappop(h)
        for son in sons(father):
            if son not in visited:
                visited.append(son)
                print(len(visited))
                fathers[son2str(son)] = father
                if son == goal:
                    res = []
                    node = son
                    while node != start:
                        res.append(node)
                        node = fathers[son2str(node)]
                    res.append(start)
                    res.reverse()
                    print(res)
                    return res
                else:
                    heappush(h,(heuristica(son,goal),son))
    print("Sem Solucao")

start = [[4,1,3],[2,5,6],[0,7,8]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]
# 4 1 3       1 2 3
# 2 5 6   ->  4 5 6
# 0 7 8       7 8 0
# 1 +2 +0+1+0 +0+1+1+2 = 8
resp = busca_heuristica(start,goal,h2)
for s in resp:
    printPuzzle(s)
    print()

"""**2- (peso 1) - Faça puzzles onde a solução é obtida com 5, 10, 15, 20 e 25 movimentos.**"""

# 5 MOVIMENTOS --> 203146758
start = [[2,0,3],[1,4,6],[7,5,8]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 2 (MANHATAN)
resp = busca_heuristica(start,goal,h2)
for s in resp:
    #printPuzzle(s)
    print()

# 5 MOVIMENTOS --> 203146758
start = [[2,0,3],[1,4,6],[7,5,8]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 1 
resp = busca_heuristica(start,goal,h1)
for s in resp:
    #printPuzzle(s)
    print()

# 10 MOVIMENTOS --> 162703548
start = [[1,6,2],[7,0,3],[5,4,8]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 2 (MANHATAN)
resp = busca_heuristica(start,goal,h2)
for s in resp:
    #printPuzzle(s)
    print()

# 10 MOVIMENTOS --> 162703548
start = [[1,6,2],[7,0,3],[5,4,8]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 1 
resp = busca_heuristica(start,goal,h1)
for s in resp:
    #printPuzzle(s)
    print()

# 15 MOVIMENTOS --> 126430785
start = [[1,2,6],[4,3,0],[7,8,5]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 2 (MANHATAN)
resp = busca_heuristica(start,goal,h2)
for s in resp:
    #printPuzzle(s)
    print()

# 15 MOVIMENTOS --> 126430785
start = [[1,2,6],[4,3,0],[7,8,5]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 1 
resp = busca_heuristica(start,goal,h1)
for s in resp:
    #printPuzzle(s)
    print()

# 20 MOVIMENTOS --> 430152786
start = [[4,3,0],[1,5,2],[7,8,6]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 2 (MANHATAN)
resp = busca_heuristica(start,goal,h2)
for s in resp:
    #printPuzzle(s)
    print()

# 20 MOVIMENTOS --> 430152786
start = [[4,3,0],[1,5,2],[7,8,6]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 1
resp = busca_heuristica(start,goal,h1)
for s in resp:
    #printPuzzle(s)
    print()

# 25 MOVIMENTOS --> 432016758
start = [[4,3,2],[0,1,6],[7,5,8]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 2 (MANHATAN)
resp = busca_heuristica(start,goal,h2)
for s in resp:
    #printPuzzle(s)
    print()

# 25 MOVIMENTOS --> 432016758
start = [[4,3,2],[0,1,6],[7,5,8]]
goal  = [[1,2,3],[4,5,6],[7,8,0]]

# HEURISTICA 1
resp = busca_heuristica(start,goal,h1)
for s in resp:
    #printPuzzle(s)
    print()

"""**3 - (peso 3) -  Faça um gráfico de linha onde o eixo x são os número de movimentos para encontrar a solução  (5, 10, 15, 20 e 25 movimentos) e o eixo y representa o número de nós visitados. Neste mesmo gráfico você deve mostrar uma linha que representa a heurística 1 e uma segunda linha que representa a heurística 2 (distancia manhattan)**"""

import matplotlib.pyplot as plt
import numpy as np

x1 = np.array([5, 10, 15, 20, 25])
y1 = np.array([11, 27, 85, 837, 1448]) # Numero de Nos visitados pela heuristica 1
x2 = np.array([5, 10, 15, 20, 25])
y2 = np.array([11, 30, 104, 914, 917]) # Numero de Nos visitados pela heuristica 2
plt.title("Comparação Heurísticas H1 e H2")
plt.xlabel("Número de movimentos para resolver o Puzzle")
plt.ylabel("Número de Nós Visitados")
plt.plot(x1, y1, 'b', label='H1', marker='o')
plt.plot(x2, y2, 'r', label='H2', marker='o')
plt.legend()
plt.show()

"""**4 -(peso 5)  Faça adaptações no código para implementar o A* e plote os gráficos similarmente a parte 3.**"""

from collections import deque

def distBetween(current,neighbor): # distancia do no atual ate o vizinho
        coord = []
        for i in range(len(current)):
            for j in range(len(current[i])):
                if current[i][j] == 0 or neighbor[i][j] == 0:
                    coord.append([i,j])
                if len(coord) == 2:
                    firstPosition = coord[0][0] * len(current) + coord[0][1]
                    secondPosition = coord[1][0] * len(current) + coord[1][1]
                    return abs(firstPosition - secondPosition)
        return 0

def heuristicEstimate(start,goal): # heuristica que estima o custo até o destino
        cost = 0
        for i in range(len(start)):
            for j in range(len(start[i])):
                if start[i][j] != goal[i][j]:
                    cost += 1
        return cost

def neighborNodes(current):
        for i in range(len(current)):
            for j in range(len(current[i])):
                if current[i][j] == 0:
                    nodes = []
                    if i-1 >= 0:
                        nodes.append(makeMove(current,i-1,j,i,j))
                    if i+1 < len(current):
                        nodes.append(makeMove(current,i+1,j,i,j))
                    if j-1 >= 0:
                        nodes.append(makeMove(current,i,j-1,i,j))
                    if j+1 < len(current[i]):
                        nodes.append(makeMove(current,i,j+1,i,j))
                    return nodes
        return []

def makeMove(current,i,j,x,y):
        lst = list(map(list,current))
        temp = lst[x][y]
        lst[x][y] = lst[i][j]
        lst[i][j] = temp
        return tuple(map(tuple,lst))
    
def reconstructPath(cameFrom,goal): # função que reconstroi o caminho para exibir o resultado
        path = deque()
        node = goal
        node2 = 0
        path.appendleft(node)
        while node in cameFrom:
            node = cameFrom[node]
            path.appendleft(node)
        return path
    
def getLowest(openSet,fScore): # calcula o menor valor de fScore do conjunto inicial / avaliado; 
        lowest = float("inf")
        lowestNode = None
        for node in openSet:
            if fScore[node] < lowest:
                lowest = fScore[node]
                lowestNode = node
        return lowestNode

# A* utilizando outra implementação 
def aStar(start,goal):
        cameFrom = {}
        openSet = set([start])
        closedSet = set()
        gScore = {}
        fScore = {}
        gScore[start] = 0
        fScore[start] = gScore[start] + heuristicEstimate(start,goal)
        conta = 0
        while len(openSet) != 0:
            current = getLowest(openSet,fScore)
            if current == goal:
                return reconstructPath(cameFrom,goal)
            openSet.remove(current)
            conta += 1
            print(conta)
            closedSet.add(current)
            for neighbor in neighborNodes(current):
                tentative_gScore = gScore[current] + distBetween(current,neighbor)
                if neighbor in closedSet and tentative_gScore >= gScore[neighbor]:
                    continue
                if neighbor not in closedSet or tentative_gScore < gScore[neighbor]:
                    cameFrom[neighbor] = current
                    gScore[neighbor] = tentative_gScore
                    fScore[neighbor] = gScore[neighbor] + heuristicEstimate(neighbor,goal)
                    if neighbor not in openSet:
                        openSet.add(neighbor)
        return 0

# 25 MOVIMENTOS --> 432016758
start = ((4,3,2),(0,1,6),(7,5,8))
goal  = ((1,2,3),(4,5,6),(7,8,0))
aStar(start, goal)

# 20 MOVIMENTOS --> 430152786
start = ((4,3,0),(1,5,2),(7,8,6))
goal  = ((1,2,3),(4,5,6),(7,8,0))
aStar(start, goal)

# 15 MOVIMENTOS --> 126430785
start = ((1,2,6),(4,3,0),(7,8,5))
goal  = ((1,2,3),(4,5,6),(7,8,0))
aStar(start, goal)

# 10 MOVIMENTOS --> 162703548
start = ((1,6,2),(7,0,3),(5,4,8))
goal  = ((1,2,3),(4,5,6),(7,8,0))
aStar(start, goal)

# 5 MOVIMENTOS --> 203146758
start = ((2,0,3),(1,4,6),(7,5,8))
goal  = ((1,2,3),(4,5,6),(7,8,0))
aStar(start, goal)

import matplotlib.pyplot as plt
import numpy as np

x1 = np.array([5, 10, 15, 20, 25])
y1 = np.array([8, 175, 1454, 4004, 5537]) # Numero de Nos visitados 
plt.title("Algoritmo A*")
plt.xlabel("Número de movimentos para resolver o Puzzle")
plt.ylabel("Número de Nós Visitados")
plt.plot(x1, y1, 'r', label='H1', marker='o')
plt.show()

"""**Algoritmo BFS visitou 16201 nós com puzzle de 25 movimentos**

**Algoritmo A* visitou 5537 nós com puzzle de 25 movimentos**
"""